---
title: 模块注册机制
date: 2022-9-9 16:43:23
categories: C++
tags: C++
---

最近在梳理项目代码时，发现现有的很多业务模块代码都集中在一个地方进行初始化，如下所示

```c++
// CCommonModule
void addActivitysList(){
    // ...
    m_pNormalRankModule = new NormalRankModule(this);
    m_pCommonTaskModule = new CommonTaskModule(this);
    // ...
}
```

类似这种写法，每次新增一个业务模块，对应的模块代码都要在这里额外写一行代码，有点麻烦且不优雅，由此联想到一种机制：在编写新模块代码时能否在对应模块中将自己注册进去，由一个公共模块统一去管理，简单实现思路如下：

```c++
// 公共模块管理类
class CCommonModule : public CSingleton<CCommonModule> {
    // ...
private:
    std::map<std::string, void*> m_mapModules;
    std::map<std::string, std::function<void* (CCommonModule* pModule)>> m_moduleDelegate;
public:
    template<typename T>
    struct RegisterModule_t {
        RegisterModule_t(const std::string& strKey) {
            CCommonModule::getSafeInstance()->m_moduleDelegate.insert(std::make_pair(strKey,
                [](CCommonModule* pModule) {
                    return (void*)(new T(pModule));
                }
            ));
        }
    };
    void InitModules() {
        for (auto& iter : m_moduleDelegate) {
            auto pModule = iter.second(this);
            if (!pModule) {
                continue;
            }
            m_mapModules.insert(std::make_pair(iter.first, pModule));
        }
    }
    //...
}
// 模块注册宏
#define REGISTER_MODULE_CLASS(T) CCommonModule::RegisterModule_t<T> reg_name_##T##_(#T)
```

每次新增新的业务模块代码时，添加使用模块注册宏`REGISTER_MODULE_CLASS`如下：

```c++
// .h
class CTestModule {
public:
    CTestModule();
    ~CTestModule();
};
// .cpp
REGISTER_MODULE_CLASS(CTestModule);
CTestModule::CTestModule(){
}
CTestModule::~CTestModule(){
}
```

最后由公共模块类调用`InitModules`即可。
